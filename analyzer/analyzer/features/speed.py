#  This file is part of 'analyzer', the tool used to process the information
#  collected for Andrea Esposito's Thesis.
#  Copyright (C) 2020  Andrea Esposito
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.

import math
import statistics
from copy import copy
from typing import List, Tuple

from .base import BasicStats
from ..data import Interaction
from ..data.base import ScreenCoordinates, Speed2D


def speed(pos0: ScreenCoordinates, pos1: ScreenCoordinates, time: int) -> Speed2D:
    """Get the speed of a bidimensional movement.

    This function calculates the speed of a movement between two point in the
    bidimensional space.

    Parameters
    ----------
    pos0 : (float, float)
        The starting position.
    pos1 : (float, float)
        The final position.
    time : float
        The time needed to move from `pos0` to `pos1`.

    Returns
    -------
    tot_speed : float
        The velocity's magnitude (or speed).
    x_speed : float
        The velocity's x component.
    y_speed : float
        The velocity's y component.
    """
    x_dist = pos1.x - pos0.x
    y_dist = pos1.y - pos0.y

    x_speed = x_dist / time
    y_speed = y_dist / time
    tot_speed = math.sqrt((x_speed ** 2) + (y_speed ** 2))

    return Speed2D(total=tot_speed, x=x_speed, y=y_speed)


def acceleration(v0: Speed2D, v1: Speed2D, time: int) -> Speed2D:
    v_x = v1.x - v0.x
    v_y = v1.y - v0.y

    x_acc = v_x / time
    y_acc = v_y / time
    tot_acc = math.sqrt((x_acc ** 2) + (y_acc ** 2))

    return Speed2D(total=tot_acc, x=x_acc, y=y_acc)


# The speed is in pixels per millisecond
def interactions_set_speed(interactions: List[Interaction]):
    interactions[0].mouse.speed = Speed2D(0, 0, 0)
    interactions[0].mouse.acceleration = Speed2D(0, 0, 0)
    helper = interactions[0].url

    for i, obj in enumerate(interactions):
        if i == 0:
            continue

        prev = interactions[i - 1]
        if obj.url == helper and (obj.timestamp - prev.timestamp) < 200:
            # There may be objects with the same timestamp, generated by an
            # interaction and the webcam at the same time. In that case, simply clone
            # the previous object's speed
            if obj.timestamp == prev.timestamp:
                obj.mouse.speed = copy(prev.mouse.speed)
                obj.mouse.acceleration = copy(prev.mouse.acceleration)
                continue

            obj.mouse.speed = speed(
                prev.mouse.position,
                obj.mouse.position,
                obj.timestamp - prev.timestamp
            )
            obj.mouse.acceleration = acceleration(
                prev.mouse.speed,
                obj.mouse.speed,
                obj.timestamp - prev.timestamp
            )
        else:
            obj.mouse.speed = Speed2D(0, 0, 0)
            obj.mouse.acceleration = Speed2D(0, 0, 0)
            helper = obj.url


def average_speed(interactions: List[Interaction]) -> Tuple[BasicStats, BasicStats, BasicStats]:
    if not interactions:
        return BasicStats(0, 0, 0), BasicStats(0, 0, 0), BasicStats(0, 0, 0)
    elif len(interactions) == 1:
        s = interactions[0].mouse.speed
        return BasicStats(s.total, s.total, 0), BasicStats(s.x, s.x, 0), BasicStats(s.y, s.y, 0)

    tot_speed = []
    x_speed = []
    y_speed = []

    for obj in interactions:
        tot_speed.append(obj.mouse.speed.total)
        x_speed.append(obj.mouse.speed.x)
        y_speed.append(obj.mouse.speed.y)

    try:
        return BasicStats(sum(tot_speed), statistics.mean(tot_speed), statistics.stdev(tot_speed)), \
               BasicStats(sum(x_speed), statistics.mean(x_speed), statistics.stdev(x_speed)), \
               BasicStats(sum(y_speed), statistics.mean(y_speed), statistics.stdev(y_speed))
    except statistics.StatisticsError:
        print(interactions)
        raise


def average_acceleration(interactions: List[Interaction]) -> Tuple[BasicStats, BasicStats, BasicStats]:
    if not interactions:
        return BasicStats(0, 0, 0), BasicStats(0, 0, 0), BasicStats(0, 0, 0)
    tot_acc = []
    x_acc = []
    y_acc = []

    for obj in interactions:
        tot_acc.append(obj.mouse.acceleration.total)
        x_acc.append(obj.mouse.acceleration.x)
        y_acc.append(obj.mouse.acceleration.y)

    return BasicStats(sum(tot_acc), statistics.mean(tot_acc), statistics.stdev(tot_acc)), \
           BasicStats(sum(x_acc), statistics.mean(x_acc), statistics.stdev(x_acc)), \
           BasicStats(sum(y_acc), statistics.mean(y_acc), statistics.stdev(y_acc))
